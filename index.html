<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ColorEconomy</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: #111;
    }
    /* Reset button styles */
    #resetButton {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      font-size: 16px;
      background: #222;
      color: white;
      border: 2px solid white;
      cursor: pointer;
      z-index: 10;
    }
    #resetButton:hover {
      background: #444;
    }
    /* Stats panel styles */
    #stats {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 250px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 10px;
      font-size: 14px;
      border: 1px solid white;
      z-index: 10;
    }
    /* Footer styles */
    #footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: black;
      color: white;
      text-align: center;
      padding: 10px;
      box-sizing: border-box;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="resetButton">Reset Simulation</button>
  <div id="stats"></div>
  <div id="footer">
    <p>
      <strong>ColorEconomy</strong> – In this simulation, tessellated patches represent a living, shifting environment with finite food resources. Bold, intense hues evolve through random splashes and neighbor interactions, but as food is drained the patches fade to grey. Creatures – odd-sided herbivores and even-sided predators – feed, fight, and mutate, their colors blending with their surroundings. Your interventions (clicks) induce mutations and mass replacement, symbolizing the delicate balance between creative diversity and ecological decay.
    </p>
  </div>
  <script>
    /* ================================
       Simulation Parameters
    ================================ */
    const SIMULATION = {
      // Terrain (Patch) Settings
      numPatches: 100,              // More patches = denser tessellation
      minPatchSides: 3,             // Minimum allowed sides per patch
      maxPatchSides: 9,             // Maximum allowed sides per patch
      
      // Patch Color Evolution & Food Resource Settings:
      neighborThreshold: 300,       // Distance within which patches influence each other
      hueAdjustmentFactor: 0.01,    // How fast patch hue moves toward the neighbors’ average
      hueRandomDrift: 0.5,          // Maximum random change in hue per tick
      lightDrift: 0.2,              // Maximum random change in lightness per tick
      boldSaturation: 100,          // Bold saturation for patches
      boldLightMin: 50,             // Minimum lightness for bold patches
      boldLightMax: 70,             // Maximum lightness for bold patches
      splashProbability: 0.03,      // Chance per patch per tick for a random color splash
      splashMaxOffset: 30,          // Maximum hue offset for splash effect
      splashLifeDecay: 0.02,        // Splash decay per tick
      patchResourceInitial: 100,    // Starting food resource per patch
      patchResourceRecovery: 0.1,   // Resource recovered per tick
      patchResourceDrain: 0.5,      // Resource drained when a herbivore feeds
      
      // Creature Settings
      initialCreatures: 100,        
      minVertices: 3,
      maxVertices: 19,
      baseEnergy: 80,
      maxEnergyThreshold: 150,
      energyDecayRate: 0.1,
      herbivoreEnergyGain: 0.2,
      predatorEnergyGain: 10,
      predatorEnergyLoss: 20,
      movementSpeed: 1,
      creatureRadius: 15,
      bounceFactor: 1,
      
      // Wiggle Settings (for creature "walking")
      wiggleRadius: 2,
      
      // Mutation Settings
      spawnMutationChance: 0.3,
      mutationChance: 1.0,
      clickReplacementRadius: 100,
      
      // Population Limit
      maxPopulation: 5000,
      
      // Debug mode
      debugMode: false
    };

    /* ================================
       Utility Functions
    ================================ */
    function randomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;
    }
    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }
    // Ray-casting point-in-polygon test.
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
                          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    // Helper: interpolate creature color toward grey based on "sickness" (0 = healthy, 1 = fully sick).
    function getSickColor(color, sickFactor) {
      const m = color.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m) return color;
      let h = m[1], s = parseInt(m[2], 10), l = parseInt(m[3], 10);
      let newS = Math.round(s * (1 - sickFactor));
      return `hsl(${h}, ${newS}%, ${l}%)`;
    }
    // Helper: blend two HSL colors.
    function blendHSL(color1, color2, weight) {
      const m1 = color1.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      const m2 = color2.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m1 || !m2) return color1;
      let h1 = parseInt(m1[1]), s1 = parseInt(m1[2]), l1 = parseInt(m1[3]);
      let h2 = parseInt(m2[1]), s2 = parseInt(m2[2]), l2 = parseInt(m2[3]);
      let dh = h2 - h1;
      if (Math.abs(dh) > 180) {
        dh = dh > 0 ? dh - 360 : dh + 360;
      }
      let h = (h1 + weight * dh + 360) % 360;
      let s = Math.round(s1 * weight + s2 * (1 - weight));
      let l = Math.round(l1 * weight + l2 * (1 - weight));
      return `hsl(${h}, ${s}%, ${l}%)`;
    }
    // Helper: get simulation statistics.
    function getStats() {
      const total = creatures.length;
      let predators = 0, prey = 0, totalCreatureEnergy = 0;
      let vertexCounts = [];
      for (let creature of creatures) {
        totalCreatureEnergy += creature.energy;
        vertexCounts.push(creature.numVertices);
        if (isHerbivore(creature)) prey++;
        else predators++;
      }
      const avgCreatureEnergy = total ? (totalCreatureEnergy / total).toFixed(1) : 0;
      const distinctTypes = new Set(vertexCounts).size;
      // Average plant energy: average food resource of patches.
      let totalPlantEnergy = 0;
      for (let patch of patches) {
        totalPlantEnergy += patch.resource;
      }
      const avgPlantEnergy = patches.length ? (totalPlantEnergy / patches.length).toFixed(1) : 0;
      return { total, predators, prey, avgCreatureEnergy, avgPlantEnergy, distinctTypes };
    }

    /* ================================
       Patch Energy Boost Function
    ================================ */
    function patchEnergyBoost(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          return (patch.light - 60) * 0.01;
        }
      }
      return 0;
    }

    /* ================================
       Canvas Setup & Global Variables
    ================================ */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const bounds = { x: 0, y: 0, w: canvas.width, h: canvas.height };
    let patches = [];
    let creatures = [];

    /* ================================
       Terrain (Patch) Generation using Voronoi
    ================================ */
    function createPatches() {
      let seeds = [];
      const gridCols = Math.ceil(Math.sqrt(SIMULATION.numPatches));
      const gridRows = Math.ceil(SIMULATION.numPatches / gridCols);
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (seeds.length >= SIMULATION.numPatches) break;
          const x = (c + 0.5) * canvas.width / gridCols + randRange(-50, 50);
          const y = (r + 0.5) * canvas.height / gridRows + randRange(-50, 50);
          seeds.push({ x, y });
        }
      }
      patches = [];
      for (let seed of seeds) {
        let cell = computeVoronoiCell(seed, seeds, bounds);
        if (cell.length < SIMULATION.minPatchSides) continue;
        while (cell.length > SIMULATION.maxPatchSides) {
          cell.splice(Math.floor(Math.random() * cell.length), 1);
        }
        let hue = randRange(0, 360);
        let sat = SIMULATION.boldSaturation;
        let light = randRange(SIMULATION.boldLightMin, SIMULATION.boldLightMax);
        patches.push({
          vertices: cell,
          hue: hue,
          sat: sat,
          light: light,
          resource: SIMULATION.patchResourceInitial || 100,
          baseColor: `hsl(${Math.round(hue)}, ${sat}%, ${Math.round(light)}%)`,
          splash: null
        });
      }
    }

    function computeVoronoiCell(seed, seeds, bounds) {
      let cell = [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h },
        { x: bounds.x, y: bounds.y + bounds.h }
      ];
      for (let other of seeds) {
        if (other === seed) continue;
        const mid = { x: (seed.x + other.x) / 2, y: (seed.y + other.y) / 2 };
        let normal = { x: seed.x - other.x, y: seed.y - other.y };
        const len = Math.hypot(normal.x, normal.y);
        if (len === 0) continue;
        normal.x /= len;
        normal.y /= len;
        cell = clipPolygon(cell, mid, normal);
        if (cell.length === 0) break;
      }
      return cell;
    }

    function clipPolygon(subjectPolygon, p, normal) {
      let outputList = [];
      for (let i = 0; i < subjectPolygon.length; i++) {
        const cur = subjectPolygon[i];
        const prev = subjectPolygon[(i - 1 + subjectPolygon.length) % subjectPolygon.length];
        const curDot = (cur.x - p.x) * normal.x + (cur.y - p.y) * normal.y;
        const prevDot = (prev.x - p.x) * normal.x + (prev.y - p.y) * normal.y;
        if (curDot >= 0) {
          if (prevDot < 0) {
            const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
            if (intersect) outputList.push(intersect);
          }
          outputList.push(cur);
        } else if (prevDot >= 0) {
          const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
          if (intersect) outputList.push(intersect);
        }
      }
      return outputList;
    }

    function lineIntersection(p1, p2, p3, p4) {
      const A1 = p2.y - p1.y;
      const B1 = p1.x - p2.x;
      const C1 = A1 * p1.x + B1 * p1.y;
      const A2 = p4.y - p3.y;
      const B2 = p3.x - p4.x;
      const C2 = A2 * p3.x + B2 * p3.y;
      const det = A1 * B2 - A2 * B1;
      if (Math.abs(det) < 0.00001) return null;
      const x = (B2 * C1 - B1 * C2) / det;
      const y = (A1 * C2 - A2 * C1) / det;
      return { x, y };
    }

    /* ================================
       Patch Color Evolution, Resource, & Splash Effects
    ================================ */
    function updatePatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        let center = { x: 0, y: 0 };
        for (let p of patch.vertices) {
          center.x += p.x;
          center.y += p.y;
        }
        center.x /= patch.vertices.length;
        center.y /= patch.vertices.length;
        patch.center = center;
        let sumHue = 0, count = 0;
        for (let other of patches) {
          if (other === patch) continue;
          if (!other.center) continue;
          let dx = other.center.x - center.x;
          let dy = other.center.y - center.y;
          if (Math.hypot(dx, dy) < SIMULATION.neighborThreshold) {
            sumHue += other.hue;
            count++;
          }
        }
        if (count > 0) {
          let avgHue = sumHue / count;
          patch.hue += (avgHue - patch.hue) * SIMULATION.hueAdjustmentFactor;
        }
        patch.hue += randRange(-SIMULATION.hueRandomDrift, SIMULATION.hueRandomDrift);
        patch.light += randRange(-SIMULATION.lightDrift, SIMULATION.lightDrift);
        patch.hue = (patch.hue + 360) % 360;
        patch.light = Math.min(90, Math.max(60, patch.light));
        patch.resource = Math.min(100, patch.resource + SIMULATION.patchResourceRecovery);
        let effectiveSat = SIMULATION.boldSaturation * (patch.resource / 100);
        if (!patch.splash && Math.random() < SIMULATION.splashProbability) {
          patch.splash = {
            hueOffset: randRange(-SIMULATION.splashMaxOffset, SIMULATION.splashMaxOffset),
            life: 1
          };
        }
        if (patch.splash) {
          patch.splash.life -= SIMULATION.splashLifeDecay;
          if (patch.splash.life <= 0) patch.splash = null;
        }
        let effectiveHue = patch.hue + (patch.splash ? patch.splash.hueOffset * patch.splash.life : 0);
        patch.baseColor = `hsl(${Math.round(effectiveHue)}, ${Math.round(effectiveSat)}%, ${Math.round(patch.light)}%)`;
      }
    }

    /* ================================
       Creature Generation & Mutation
    ================================ */
    function generateTwistedShape(numVertices, radius) {
      let points = [];
      for (let i = 0; i < numVertices; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = radius * randRange(0.5, 1.5);
        points.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
      }
      return points;
    }
    function spawnCreature() {
      let numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
      let creature = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        numVertices: numVertices,
        baseShape: generateTwistedShape(numVertices, SIMULATION.creatureRadius),
        color: randomColor(),
        energy: SIMULATION.baseEnergy,
        maxEnergy: SIMULATION.maxEnergyThreshold,
        radius: SIMULATION.creatureRadius,
        colliding: false  // flag to indicate visual collision
      };
      if (Math.random() < SIMULATION.spawnMutationChance) {
        creature.numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
        creature.baseShape = generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius);
      }
      return creature;
    }
    for (let i = 0; i < SIMULATION.initialCreatures; i++) {
      creatures.push(spawnCreature());
    }

    /* ================================
       Creature Behavior: Type & Interaction
    ================================ */
    function isHerbivore(creature) {
      return creature.numVertices % 2 === 1;
    }
    function herbivoreFeeding(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          if (patch.vertices.length % creature.numVertices === 0 && patch.resource > 0) {
            creature.energy += SIMULATION.herbivoreEnergyGain;
            patch.resource = Math.max(0, patch.resource - SIMULATION.patchResourceDrain);
          }
          break;
        }
      }
    }
    function creaturesCollide(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const dist = Math.hypot(dx, dy);
      return dist < (c1.radius + c2.radius);
    }
    function handleCreatureCollisions() {
      // Clear collision flags first.
      for (let creature of creatures) {
        creature.colliding = false;
      }
      for (let i = 0; i < creatures.length; i++) {
        for (let j = i + 1; j < creatures.length; j++) {
          let a = creatures[i];
          let b = creatures[j];
          if (creaturesCollide(a, b)) {
            // Mark as colliding to trigger visual effect.
            a.colliding = true;
            b.colliding = true;
            if (!isHerbivore(a) || !isHerbivore(b)) {
              if (a.energy > b.energy * 1.1) {
                a.energy += SIMULATION.predatorEnergyGain;
                b.energy -= SIMULATION.predatorEnergyLoss;
              } else if (b.energy > a.energy * 1.1) {
                b.energy += SIMULATION.predatorEnergyGain;
                a.energy -= SIMULATION.predatorEnergyLoss;
              } else {
                const angle = Math.atan2(b.y - a.y, b.x - a.x);
                a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
                a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
                b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
                b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
              }
            } else {
              const angle = Math.atan2(b.y - a.y, b.x - a.x);
              a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
              a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
              b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
              b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
            }
          }
        }
      }
    }

    /* ================================
       Update Loop
    ================================ */
    function updateCreatures() {
      for (let creature of creatures) {
        creature.x += creature.dx;
        creature.y += creature.dy;
        if (creature.x < 0 || creature.x > canvas.width) creature.dx *= -1;
        if (creature.y < 0 || creature.y > canvas.height) creature.dy *= -1;
        creature.energy -= SIMULATION.energyDecayRate;
        creature.energy += patchEnergyBoost(creature);
        if (isHerbivore(creature)) {
          herbivoreFeeding(creature);
        }
        if (creature.energy >= creature.maxEnergy) {
          creature.energy /= 2;
          let clone = {
            x: creature.x + randRange(-5, 5),
            y: creature.y + randRange(-5, 5),
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: creature.numVertices,
            baseShape: generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius),
            color: creature.color,
            energy: creature.energy,
            maxEnergy: creature.maxEnergy,
            radius: creature.radius,
            colliding: false
          };
          creatures.push(clone);
        }
      }
      handleCreatureCollisions();
      if (creatures.length > SIMULATION.maxPopulation) {
        creatures.sort((a, b) => a.energy - b.energy);
        creatures = creatures.slice(creatures.length - SIMULATION.maxPopulation);
      }
      creatures = creatures.filter(c => c.energy > 0);
    }

    /* ================================
       Drawing Functions
    ================================ */
    function drawPatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        ctx.beginPath();
        ctx.moveTo(patch.vertices[0].x, patch.vertices[0].y);
        for (let i = 1; i < patch.vertices.length; i++) {
          ctx.lineTo(patch.vertices[i].x, patch.vertices[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = patch.baseColor;
        ctx.fill();
      }
    }
    function drawCreatures() {
      for (let creature of creatures) {
        // Find the patch under this creature.
        let currentPatch = null;
        for (let patch of patches) {
          if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
            currentPatch = patch;
            break;
          }
        }
        let blendedColor = creature.color;
        if (currentPatch) {
          blendedColor = blendHSL(creature.color, currentPatch.baseColor, 0.5);
        }
        ctx.save();
        ctx.translate(creature.x, creature.y);
        ctx.beginPath();
        let pts = creature.baseShape;
        for (let i = 0; i < pts.length; i++) {
          let offsetX = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let offsetY = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let x = pts[i].x + offsetX;
          let y = pts[i].y + offsetY;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        let sickFactor = Math.min(1, Math.max(0, 1 - (creature.energy / SIMULATION.baseEnergy)));
        let finalColor = getSickColor(blendedColor, sickFactor);
        ctx.fillStyle = finalColor;
        ctx.fill();
        // If colliding, draw a red outline.
        if (creature.colliding) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
        } else {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
        }
        ctx.stroke();
        ctx.restore();
      }
    }

    /* ================================
       Click Replacement:
       Replace all creatures in a radius with a new type.
    ================================ */
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      let indicesToReplace = [];
      for (let i = 0; i < creatures.length; i++) {
        let creature = creatures[i];
        let dx = creature.x - clickX;
        let dy = creature.y - clickY;
        if (Math.hypot(dx, dy) < SIMULATION.clickReplacementRadius) {
          indicesToReplace.push(i);
        }
      }
      if (indicesToReplace.length > 0) {
        let newConfig = spawnCreature();
        indicesToReplace.forEach(index => {
          let old = creatures[index];
          creatures[index] = {
            x: old.x,
            y: old.y,
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: newConfig.numVertices,
            baseShape: generateTwistedShape(newConfig.numVertices, SIMULATION.creatureRadius),
            color: newConfig.color,
            energy: SIMULATION.baseEnergy,
            maxEnergy: SIMULATION.maxEnergyThreshold,
            radius: SIMULATION.creatureRadius,
            colliding: false
          };
        });
      }
    });

    /* ================================
       Stats Panel Update
    ================================ */
    function updateStats() {
      const statsDiv = document.getElementById("stats");
      const { total, predators, prey, avgCreatureEnergy, avgPlantEnergy, vertexStdDev, distinctTypes } = (function() {
        const total = creatures.length;
        let predators = 0, prey = 0, totalCreatureEnergy = 0;
        let vertexCounts = [];
        for (let creature of creatures) {
          totalCreatureEnergy += creature.energy;
          vertexCounts.push(creature.numVertices);
          if (isHerbivore(creature)) prey++;
          else predators++;
        }
        const avgCreatureEnergy = total ? (totalCreatureEnergy / total).toFixed(1) : 0;
        // Biodiversity: distinct creature types based on vertex count.
        const distinctTypes = new Set(vertexCounts).size;
        // Average plant energy (i.e. resource in patches).
        let totalPlantEnergy = 0;
        for (let patch of patches) {
          totalPlantEnergy += patch.resource;
        }
        const avgPlantEnergy = patches.length ? (totalPlantEnergy / patches.length).toFixed(1) : 0;
        return { total, predators, prey, avgCreatureEnergy, avgPlantEnergy, distinctTypes };
      })();
      statsDiv.innerHTML = `<strong>Simulation Stats</strong><br>
                            Total Population: ${total}<br>
                            Predators: ${predators} | Prey: ${prey}<br>
                            Avg Creature Energy: ${avgCreatureEnergy}<br>
                            Avg Plant Energy: ${avgPlantEnergy}<br>
                            Biodiversity (distinct types): ${distinctTypes}`;
    }

    /* ================================
       Main Game Loop
    ================================ */
    function gameLoop() {
      updatePatches();
      updateCreatures();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPatches();
      drawCreatures();
      updateStats();
      requestAnimationFrame(gameLoop);
    }

    /* ================================
       Reset Simulation Functionality
    ================================ */
    document.getElementById("resetButton").addEventListener("click", function() {
      creatures = [];
      for (let i = 0; i < SIMULATION.initialCreatures; i++) {
        creatures.push(spawnCreature());
      }
    });

    /* ================================
       Initialization
    ================================ */
    function initPatchResources() {
      for (let patch of patches) {
        patch.resource = SIMULATION.patchResourceInitial || 100;
      }
    }
    createPatches();
    initPatchResources();
    gameLoop();
  </script>
</body>
</html>
