<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ColorEconomy</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: #111;
    }
    /* Reset button styles */
    #resetButton {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      font-size: 16px;
      background: #222;
      color: white;
      border: 2px solid white;
      cursor: pointer;
      z-index: 10;
    }
    #resetButton:hover {
      background: #444;
    }
    /* Stats and controls panel styles */
    #stats {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 320px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 10px;
      font-size: 14px;
      border: 1px solid white;
      z-index: 10;
      max-height: 90vh;
      overflow-y: auto;
    }
    #stats div.control {
      margin-bottom: 8px;
    }
    #stats label {
      display: block;
      margin-bottom: 2px;
    }
    #stats input[type="range"] {
      width: 100%;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="resetButton">Reset Simulation</button>
  <div id="stats">
    <div><strong>Simulation Stats</strong></div>
    <div id="statsValues"></div>
    <hr>
    <div class="control">
      <label>Starting Creatures: <span id="valStart">100</span></label>
      <input type="range" id="sliderStart" min="100" max="1000" step="100" value="100">
    </div>
    <div class="control">
      <label>Predator Birth Rate: <span id="valPredator">1.0</span></label>
      <input type="range" id="sliderPredatorBirthRate" min="0.5" max="2.0" step="0.1" value="1.0">
    </div>
    <div class="control">
      <label>Prey Birth Rate: <span id="valPrey">1.0</span></label>
      <input type="range" id="sliderPreyBirthRate" min="0.5" max="2.0" step="0.1" value="1.0">
    </div>
    <div class="control">
      <label>Diversity: <span id="valDiversity">1.0</span></label>
      <input type="range" id="sliderDiversity" min="0.5" max="2.0" step="0.1" value="1.0">
    </div>
    <hr>
    <div>
      <strong>About ColorEconomy:</strong><br>
      Tessellated patches are a dynamic ecosystem with finite food resources. Bold patch colors fade to grey as food is drained. Odd‐sided herbivores actively seek patches that “fit” their form, while even‐sided predators pursue prey and move faster. Creature cloning occurs when energy thresholds (adjusted by birth rates) are reached—when that happens, a glowing outline signals multiplication. Your interactions (clicks) induce mass replacement, revealing the fragile balance between diversity and decay.
    </div>
  </div>
  <script>
    /* ================================
       Simulation Parameters
    ================================ */
    const SIMULATION = {
      // Terrain (Patch) Settings
      numPatches: 100,
      minPatchSides: 3,
      maxPatchSides: 8,
      
      // Patch Color & Food Settings:
      neighborThreshold: 300,
      hueAdjustmentFactor: 0.01,
      hueRandomDrift: 0.5,
      lightDrift: 0.2,
      boldSaturation: 100,
      boldLightMin: 50,
      boldLightMax: 70,
      splashProbability: 0.03,
      splashMaxOffset: 30,
      splashLifeDecay: 0.02,
      patchResourceInitial: 100,
      patchResourceRecovery: 0.1,
      patchResourceDrain: 0.5,
      
      // Creature Settings
      initialCreatures: 100,       // default 100 (slider-controlled)
      minVertices: 3,
      maxVertices: 8,
      baseEnergy: 80,
      maxEnergyThreshold: 150,
      energyDecayRate: 0.1,
      herbivoreEnergyGain: 0.2,
      predatorEnergyGain: 10,
      predatorEnergyLoss: 20,
      movementSpeed: 1,
      creatureRadius: 15,
      bounceFactor: 1,
      
      // Wiggle Settings
      wiggleRadius: 2,
      
      // Mutation Settings
      spawnMutationChance: 0.3,
      mutationChance: 1.0,
      clickReplacementRadius: 100,
      
      // Population Limit (10x starting creatures)
      maxPopulation: 1000,
      
      // New Parameters from Sliders:
      predatorBirthRate: 1.0,
      preyBirthRate: 1.0,
      diversity: 1.0,
      
      // Debug mode
      debugMode: false
    };

    /* ================================
       Utility Functions
    ================================ */
    function randomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;
    }
    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
                          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function getSickColor(color, sickFactor) {
      const m = color.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m) return color;
      let h = m[1], s = parseInt(m[2], 10), l = parseInt(m[3], 10);
      let newS = Math.round(s * (1 - sickFactor));
      return `hsl(${h}, ${newS}%, ${l}%)`;
    }
    function blendHSL(color1, color2, weight) {
      const m1 = color1.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      const m2 = color2.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m1 || !m2) return color1;
      let h1 = parseInt(m1[1]), s1 = parseInt(m1[2]), l1 = parseInt(m1[3]);
      let h2 = parseInt(m2[1]), s2 = parseInt(m2[2]), l2 = parseInt(m2[3]);
      let dh = h2 - h1;
      if (Math.abs(dh) > 180) { dh = dh > 0 ? dh - 360 : dh + 360; }
      let h = (h1 + weight * dh + 360) % 360;
      let s = Math.round(s1 * weight + s2 * (1 - weight));
      let l = Math.round(l1 * weight + l2 * (1 - weight));
      return `hsl(${h}, ${s}%, ${l}%)`;
    }
    function getStats() {
      const total = creatures.length;
      let predators = 0, prey = 0, totalCreatureEnergy = 0;
      let vertexCounts = [];
      for (let creature of creatures) {
        totalCreatureEnergy += creature.energy;
        vertexCounts.push(creature.numVertices);
        if (isHerbivore(creature)) prey++;
        else predators++;
      }
      const avgCreatureEnergy = total ? (totalCreatureEnergy / total).toFixed(1) : 0;
      const energyProportion = total ? `${avgCreatureEnergy}/${SIMULATION.maxEnergyThreshold}` : "0";
      const meanVertices = vertexCounts.reduce((a, b) => a + b, 0) / (vertexCounts.length || 1);
      const variance = vertexCounts.reduce((a, b) => a + Math.pow(b - meanVertices, 2), 0) / (vertexCounts.length || 1);
      const stdDev = Math.sqrt(variance).toFixed(1);
      let totalPlantEnergy = 0;
      for (let patch of patches) {
        totalPlantEnergy += patch.resource;
      }
      const avgPlantEnergy = patches.length ? (totalPlantEnergy / patches.length).toFixed(1) : 0;
      const plantProportion = `${avgPlantEnergy}/100`;
      const distinctTypes = new Set(vertexCounts).size;
      return { total, predators, prey, energyProportion, plantProportion, stdDev, distinctTypes };
    }

    /* ================================
       Patch Energy Boost Function
    ================================ */
    function patchEnergyBoost(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          return (patch.light - 60) * 0.01;
        }
      }
      return 0;
    }

    /* ================================
       Canvas Setup & Global Variables
    ================================ */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const bounds = { x: 0, y: 0, w: canvas.width, h: canvas.height };
    let patches = [];
    let creatures = [];

    /* ================================
       Terrain (Patch) Generation using Voronoi
    ================================ */
    function createPatches() {
      let seeds = [];
      const gridCols = Math.ceil(Math.sqrt(SIMULATION.numPatches));
      const gridRows = Math.ceil(SIMULATION.numPatches / gridCols);
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (seeds.length >= SIMULATION.numPatches) break;
          const x = (c + 0.5) * canvas.width / gridCols + randRange(-50, 50);
          const y = (r + 0.5) * canvas.height / gridRows + randRange(-50, 50);
          seeds.push({ x, y });
        }
      }
      patches = [];
      for (let seed of seeds) {
        let cell = computeVoronoiCell(seed, seeds, bounds);
        if (cell.length < SIMULATION.minPatchSides) continue;
        while (cell.length > SIMULATION.maxPatchSides) {
          cell.splice(Math.floor(Math.random() * cell.length), 1);
        }
        let hue = randRange(0, 360);
        let sat = SIMULATION.boldSaturation;
        let light = randRange(SIMULATION.boldLightMin, SIMULATION.boldLightMax);
        patches.push({
          vertices: cell,
          hue: hue,
          sat: sat,
          light: light,
          resource: SIMULATION.patchResourceInitial,
          baseColor: `hsl(${Math.round(hue)}, ${sat}%, ${Math.round(light)}%)`,
          splash: null
        });
      }
    }
    function computeVoronoiCell(seed, seeds, bounds) {
      let cell = [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h },
        { x: bounds.x, y: bounds.y + bounds.h }
      ];
      for (let other of seeds) {
        if (other === seed) continue;
        const mid = { x: (seed.x + other.x) / 2, y: (seed.y + other.y) / 2 };
        let normal = { x: seed.x - other.x, y: seed.y - other.y };
        const len = Math.hypot(normal.x, normal.y);
        if (len === 0) continue;
        normal.x /= len;
        normal.y /= len;
        cell = clipPolygon(cell, mid, normal);
        if (cell.length === 0) break;
      }
      return cell;
    }
    function clipPolygon(subjectPolygon, p, normal) {
      let outputList = [];
      for (let i = 0; i < subjectPolygon.length; i++) {
        const cur = subjectPolygon[i];
        const prev = subjectPolygon[(i - 1 + subjectPolygon.length) % subjectPolygon.length];
        const curDot = (cur.x - p.x) * normal.x + (cur.y - p.y) * normal.y;
        const prevDot = (prev.x - p.x) * normal.x + (prev.y - p.y) * normal.y;
        if (curDot >= 0) {
          if (prevDot < 0) {
            const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
            if (intersect) outputList.push(intersect);
          }
          outputList.push(cur);
        } else if (prevDot >= 0) {
          const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
          if (intersect) outputList.push(intersect);
        }
      }
      return outputList;
    }
    function lineIntersection(p1, p2, p3, p4) {
      const A1 = p2.y - p1.y;
      const B1 = p1.x - p2.x;
      const C1 = A1 * p1.x + B1 * p1.y;
      const A2 = p4.y - p3.y;
      const B2 = p3.x - p4.x;
      const C2 = A2 * p3.x + B2 * p3.y;
      const det = A1 * B2 - A2 * B1;
      if (Math.abs(det) < 0.00001) return null;
      const x = (B2 * C1 - B1 * C2) / det;
      const y = (A1 * C2 - A2 * C1) / det;
      return { x, y };
    }

    /* ================================
       Patch Color Evolution, Resource, & Splash Effects
    ================================ */
    function updatePatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        let center = { x: 0, y: 0 };
        for (let p of patch.vertices) {
          center.x += p.x;
          center.y += p.y;
        }
        center.x /= patch.vertices.length;
        center.y /= patch.vertices.length;
        patch.center = center;
        let sumHue = 0, count = 0;
        for (let other of patches) {
          if (other === patch) continue;
          if (!other.center) continue;
          let dx = other.center.x - center.x;
          let dy = other.center.y - center.y;
          if (Math.hypot(dx, dy) < SIMULATION.neighborThreshold) {
            sumHue += other.hue;
            count++;
          }
        }
        if (count > 0) {
          let avgHue = sumHue / count;
          patch.hue += (avgHue - patch.hue) * SIMULATION.hueAdjustmentFactor;
        }
        patch.hue += randRange(-SIMULATION.hueRandomDrift, SIMULATION.hueRandomDrift);
        patch.light += randRange(-SIMULATION.lightDrift, SIMULATION.lightDrift);
        patch.hue = (patch.hue + 360) % 360;
        patch.light = Math.min(90, Math.max(60, patch.light));
        patch.resource = Math.min(100, patch.resource + SIMULATION.patchResourceRecovery);
        let effectiveSat = SIMULATION.boldSaturation * (patch.resource / 100);
        if (!patch.splash && Math.random() < SIMULATION.splashProbability) {
          patch.splash = {
            hueOffset: randRange(-SIMULATION.splashMaxOffset, SIMULATION.splashMaxOffset),
            life: 1
          };
        }
        if (patch.splash) {
          patch.splash.life -= SIMULATION.splashLifeDecay;
          if (patch.splash.life <= 0) patch.splash = null;
        }
        let effectiveHue = patch.hue + (patch.splash ? patch.splash.hueOffset * patch.splash.life : 0);
        patch.baseColor = `hsl(${Math.round(effectiveHue)}, ${Math.round(effectiveSat)}%, ${Math.round(patch.light)}%)`;
      }
    }

    /* ================================
       Creature Generation & Mutation
    ================================ */
    function generateTwistedShape(numVertices, radius) {
      let points = [];
      for (let i = 0; i < numVertices; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = radius * randRange(0.5, 1.5);
        points.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
      }
      return points;
    }
    function spawnCreature() {
      // Use the diversity slider to modify vertex range.
      const effectiveMax = Math.max(SIMULATION.minVertices + 1, Math.round(SIMULATION.maxVertices * SIMULATION.diversity));
      let numVertices = Math.floor(randRange(SIMULATION.minVertices, effectiveMax + 1));
      // For speed and size multipliers: fewer vertices → faster and smaller.
      let speedMultiplier = (SIMULATION.maxVertices + 1 - numVertices) / SIMULATION.maxVertices;
      let sizeMultiplier = 1 + (numVertices - SIMULATION.minVertices) / (SIMULATION.maxVertices - SIMULATION.minVertices) * 0.5;
      let creature = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed) * (isHerbivore({numVertices}) ? 1 : SIMULATION.predatorBirthRate * speedMultiplier),
        dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed) * (isHerbivore({numVertices}) ? 1 : SIMULATION.predatorBirthRate * speedMultiplier),
        numVertices: numVertices,
        baseShape: generateTwistedShape(numVertices, SIMULATION.creatureRadius * sizeMultiplier),
        color: randomColor(),
        energy: SIMULATION.baseEnergy,
        maxEnergy: SIMULATION.maxEnergyThreshold,
        radius: SIMULATION.creatureRadius * sizeMultiplier,
        colliding: false,
        cloneTimer: 0
      };
      if (Math.random() < SIMULATION.spawnMutationChance) {
        numVertices = Math.floor(randRange(SIMULATION.minVertices, effectiveMax + 1));
        creature.numVertices = numVertices;
        speedMultiplier = (SIMULATION.maxVertices + 1 - numVertices) / SIMULATION.maxVertices;
        sizeMultiplier = 1 + (numVertices - SIMULATION.minVertices) / (SIMULATION.maxVertices - SIMULATION.minVertices) * 0.5;
        creature.dx = randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed) * (isHerbivore({numVertices}) ? 1 : SIMULATION.predatorBirthRate * speedMultiplier);
        creature.dy = randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed) * (isHerbivore({numVertices}) ? 1 : SIMULATION.predatorBirthRate * speedMultiplier);
        creature.radius = SIMULATION.creatureRadius * sizeMultiplier;
        creature.baseShape = generateTwistedShape(numVertices, creature.radius);
      }
      return creature;
    }
    function isHerbivore(creature) {
      // If creature is passed as an object with just numVertices, treat that accordingly.
      return creature.numVertices % 2 === 1;
    }
    for (let i = 0; i < SIMULATION.initialCreatures; i++) {
      creatures.push(spawnCreature());
    }

    /* ================================
       Creature Behavior: Seeking & Interaction
    ================================ */
    function herbivoreFeeding(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          if (patch.vertices.length % creature.numVertices === 0 && patch.resource > 0) {
            creature.energy += SIMULATION.herbivoreEnergyGain;
            patch.resource = Math.max(0, patch.resource - SIMULATION.patchResourceDrain);
          }
          break;
        }
      }
    }
    function predatorSeekPrey(creature) {
      // For predators, find the closest prey and adjust velocity slightly toward it.
      let closest = null;
      let minDist = Infinity;
      for (let other of creatures) {
        if (isHerbivore(other)) {
          let d = Math.hypot(creature.x - other.x, creature.y - other.y);
          if (d < minDist) {
            minDist = d;
            closest = other;
          }
        }
      }
      if (closest) {
        // Steer towards the prey (adjust dx, dy slightly)
        let angle = Math.atan2(closest.y - creature.y, closest.x - creature.x);
        creature.dx += 0.05 * Math.cos(angle);
        creature.dy += 0.05 * Math.sin(angle);
      }
    }
    function herbivoreSeekPatch(creature) {
      // For herbivores, look for a patch that is "desirable"
      let bestPatch = null;
      let bestValue = -Infinity;
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          // Already here.
          continue;
        }
        if (patch.vertices.length % creature.numVertices === 0 && patch.resource > 0) {
          // Value could be a function of resource and distance.
          let d = Math.hypot(creature.x - patch.center.x, creature.y - patch.center.y);
          let value = patch.resource - d * 0.05;
          if (value > bestValue) {
            bestValue = value;
            bestPatch = patch;
          }
        }
      }
      if (bestPatch) {
        let angle = Math.atan2(bestPatch.center.y - creature.y, bestPatch.center.x - creature.x);
        creature.dx += 0.05 * Math.cos(angle);
        creature.dy += 0.05 * Math.sin(angle);
      }
    }
    function creaturesCollide(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const dist = Math.hypot(dx, dy);
      return dist < (c1.radius + c2.radius);
    }
    function handleCreatureCollisions() {
      for (let creature of creatures) { creature.colliding = false; }
      for (let i = 0; i < creatures.length; i++) {
        for (let j = i + 1; j < creatures.length; j++) {
          let a = creatures[i];
          let b = creatures[j];
          if (creaturesCollide(a, b)) {
            a.colliding = true;
            b.colliding = true;
            if (!isHerbivore(a) || !isHerbivore(b)) {
              if (a.energy > b.energy * 1.1) {
                a.energy += SIMULATION.predatorEnergyGain;
                b.energy -= SIMULATION.predatorEnergyLoss;
              } else if (b.energy > a.energy * 1.1) {
                b.energy += SIMULATION.predatorEnergyGain;
                a.energy -= SIMULATION.predatorEnergyLoss;
              } else {
                const angle = Math.atan2(b.y - a.y, b.x - a.x);
                a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
                a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
                b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
                b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
              }
            } else {
              const angle = Math.atan2(b.y - a.y, b.x - a.x);
              a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
              a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
              b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
              b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
            }
          }
        }
      }
    }

    /* ================================
       Update Loop
    ================================ */
    function updateCreatures() {
      for (let creature of creatures) {
        // Move creature.
        creature.x += creature.dx;
        creature.y += creature.dy;
        // Toroidal wrapping.
        if (creature.x < 0) creature.x += canvas.width;
        if (creature.x > canvas.width) creature.x -= canvas.width;
        if (creature.y < 0) creature.y += canvas.height;
        if (creature.y > canvas.height) creature.y -= canvas.height;
        creature.energy -= SIMULATION.energyDecayRate;
        creature.energy += patchEnergyBoost(creature);
        if (isHerbivore(creature)) {
          herbivoreFeeding(creature);
          herbivoreSeekPatch(creature);
        } else {
          predatorSeekPrey(creature);
        }
        // Clone when energy exceeds threshold; use birth rates to modify threshold.
        let birthRate = isHerbivore(creature) ? SIMULATION.preyBirthRate : SIMULATION.predatorBirthRate;
        if (creature.energy >= creature.maxEnergy / birthRate) {
          creature.energy /= 2;
          creature.cloneTimer = 20; // flag for visual indication.
          let clone = spawnCreature();
          clone.x = creature.x + randRange(-5, 5);
          clone.y = creature.y + randRange(-5, 5);
          clone.color = creature.color;
          clone.energy = creature.energy;
          clone.maxEnergy = creature.maxEnergy;
          creatures.push(clone);
        }
        // Decrement clone timer if set.
        if (creature.cloneTimer && creature.cloneTimer > 0) {
          creature.cloneTimer--;
        }
      }
      handleCreatureCollisions();
      if (creatures.length > SIMULATION.maxPopulation) {
        creatures.sort((a, b) => a.energy - b.energy);
        creatures = creatures.slice(creatures.length - SIMULATION.maxPopulation);
      }
      creatures = creatures.filter(c => c.energy > 0);
    }

    /* ================================
       Drawing Functions
    ================================ */
    function drawPatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        ctx.beginPath();
        ctx.moveTo(patch.vertices[0].x, patch.vertices[0].y);
        for (let i = 1; i < patch.vertices.length; i++) {
          ctx.lineTo(patch.vertices[i].x, patch.vertices[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = patch.baseColor;
        ctx.fill();
      }
    }
    function drawCreatures() {
      for (let creature of creatures) {
        // Find the patch under this creature.
        let currentPatch = null;
        for (let patch of patches) {
          if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
            currentPatch = patch;
            break;
          }
        }
        let blendedColor = creature.color;
        if (currentPatch) {
          blendedColor = blendHSL(creature.color, currentPatch.baseColor, 0.5);
        }
        ctx.save();
        ctx.translate(creature.x, creature.y);
        ctx.beginPath();
        let pts = creature.baseShape;
        for (let i = 0; i < pts.length; i++) {
          let offsetX = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let offsetY = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let x = pts[i].x + offsetX;
          let y = pts[i].y + offsetY;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        let sickFactor = Math.min(1, Math.max(0, 1 - (creature.energy / SIMULATION.baseEnergy)));
        let finalColor = getSickColor(blendedColor, sickFactor);
        ctx.fillStyle = finalColor;
        ctx.fill();
        // If colliding, draw red outline.
        if (creature.colliding) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
        } else if (creature.cloneTimer && creature.cloneTimer > 0) {
          // Outline to indicate recent multiplication.
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
        } else {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
        }
        ctx.stroke();
        ctx.restore();
      }
    }

    /* ================================
       Click Replacement:
       Replace all creatures in a radius with a new type.
    ================================ */
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      let indicesToReplace = [];
      for (let i = 0; i < creatures.length; i++) {
        let creature = creatures[i];
        let dx = creature.x - clickX;
        let dy = creature.y - clickY;
        if (Math.hypot(dx, dy) < SIMULATION.clickReplacementRadius) {
          indicesToReplace.push(i);
        }
      }
      if (indicesToReplace.length > 0) {
        let newConfig = spawnCreature();
        indicesToReplace.forEach(index => {
          let old = creatures[index];
          let speedMultiplier = (SIMULATION.maxVertices + 1 - newConfig.numVertices) / SIMULATION.maxVertices;
          let sizeMultiplier = 1 + (newConfig.numVertices - SIMULATION.minVertices) / (SIMULATION.maxVertices - SIMULATION.minVertices) * 0.5;
          creatures[index] = {
            x: old.x,
            y: old.y,
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed) * (isHerbivore(newConfig) ? 1 : SIMULATION.predatorBirthRate * speedMultiplier),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed) * (isHerbivore(newConfig) ? 1 : SIMULATION.predatorBirthRate * speedMultiplier),
            numVertices: newConfig.numVertices,
            baseShape: generateTwistedShape(newConfig.numVertices, SIMULATION.creatureRadius * sizeMultiplier),
            color: newConfig.color,
            energy: SIMULATION.baseEnergy,
            maxEnergy: SIMULATION.maxEnergyThreshold,
            radius: SIMULATION.creatureRadius * sizeMultiplier,
            colliding: false,
            cloneTimer: 0
          };
        });
      }
    });

    /* ================================
       Stats Panel Update
    ================================ */
    function updateStats() {
      const statsDiv = document.getElementById("stats");
      const { total, predators, prey, energyProportion, plantProportion, stdDev, distinctTypes } = getStats();
      statsDiv.innerHTML = `<strong>Simulation Stats</strong><br>
                            Total Population: ${total}<br>
                            Predators: ${predators} | Prey: ${prey}<br>
                            Avg Creature Energy: ${energyProportion}<br>
                            Avg Plant Energy: ${plantProportion}<br>
                            Biodiversity (distinct types): ${distinctTypes}<br>
                            Vertex Variation: ${stdDev}<br>
                            <hr>
                            <strong>Controls:</strong><br>
                            Starting Creatures, Predator/Prey Birth Rates, Diversity<br>
                            <em>(Adjust the sliders below.)</em><br>
                            <hr>
                            <strong>About ColorEconomy:</strong><br>
                            The tessellated patches represent a dynamic ecosystem with finite food resources. Bold, intense patch colors evolve as food is consumed and recovered. Odd‐sided herbivores actively seek out nutrient-rich patches, while even‐sided predators pursue prey. Creature speed and size vary with their form (fewer vertices means faster and smaller). When energy is low, colors fade to grey. Your interactions (clicks) induce mutations and mass replacement, revealing the fragile balance between diversity and decay.`;
    }

    /* ================================
       Slider Controls Setup
    ================================ */
    // Grab slider elements.
    const sliderStart = document.getElementById("sliderStart");
    const valStart = document.getElementById("valStart");
    const sliderPredator = document.getElementById("sliderPredatorBirthRate");
    const valPredator = document.getElementById("valPredator");
    const sliderPrey = document.getElementById("sliderPreyBirthRate");
    const valPrey = document.getElementById("valPrey");
    const sliderDiversity = document.getElementById("sliderDiversity");
    const valDiversity = document.getElementById("valDiversity");

    // Set initial slider values.
    sliderStart.value = SIMULATION.initialCreatures;
    sliderPredator.value = 1.0;
    sliderPrey.value = 1.0;
    sliderDiversity.value = 1.0;

    // Update simulation parameters on slider change.
    sliderStart.addEventListener("input", function() {
      SIMULATION.initialCreatures = parseInt(sliderStart.value);
      SIMULATION.maxPopulation = SIMULATION.initialCreatures * 10;
      valStart.innerText = sliderStart.value;
    });
    sliderPredator.addEventListener("input", function() {
      SIMULATION.predatorBirthRate = parseFloat(sliderPredator.value);
      valPredator.innerText = sliderPredator.value;
    });
    sliderPrey.addEventListener("input", function() {
      SIMULATION.preyBirthRate = parseFloat(sliderPrey.value);
      valPrey.innerText = sliderPrey.value;
    });
    sliderDiversity.addEventListener("input", function() {
      SIMULATION.diversity = parseFloat(sliderDiversity.value);
      valDiversity.innerText = sliderDiversity.value;
    });

    /* ================================
       Main Game Loop
    ================================ */
    function gameLoop() {
      updatePatches();
      updateCreatures();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPatches();
      drawCreatures();
      updateStats();
      requestAnimationFrame(gameLoop);
    }

    /* ================================
       Reset Simulation Functionality
    ================================ */
    document.getElementById("resetButton").addEventListener("click", function() {
      creatures = [];
      for (let i = 0; i < SIMULATION.initialCreatures; i++) {
        creatures.push(spawnCreature());
      }
    });

    /* ================================
       Initialization
    ================================ */
    function initPatchResources() {
      for (let patch of patches) {
        patch.resource = SIMULATION.patchResourceInitial;
      }
    }
    createPatches();
    initPatchResources();
    gameLoop();
  </script>
</body>
</html>
