<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ColorEconomy</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #111;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    /* ================================
       Simulation Parameters
    ================================ */
    const SIMULATION = {
      // Terrain (Patch) Settings
      numPatches: 50,              // Total number of patches (grid cells)
      
      // Creature Settings
      initialCreatures: 10000,        // Starting creature count
      minVertices: 3,              // Minimum vertices for creature shape
      maxVertices: 14,              // Maximum vertices for creature shape
      baseEnergy: 80,              // Starting energy for creatures
      maxEnergyThreshold: 150,     // Energy required for cloning
      energyDecayRate: 0.1,        // Energy lost per frame
      herbivoreEnergyGain: 0.2,    // Extra energy gain when feeding (if condition met)
      predatorEnergyGain: 10,      // Energy bonus from winning a fight
      predatorEnergyLoss: 20,      // Energy penalty from losing a fight
      movementSpeed: 1,            // Base movement speed
      creatureRadius: 15,          // For collision detection (approximate size)
      bounceFactor: 1,             // Strength of bounce on collision

      // Wiggle Settings (for creature "walking")
      wiggleRadius: 2,             // Maximum random offset per vertex per frame

      // Mutation Settings (on spawn and on click)
      spawnMutationChance: 0.3,    // Chance a newly spawned creature mutates its vertex count
      mutationChance: 1.0,         // Chance to mutate on click (if clicked creature is targeted)
      clickReplacementRadius: 100, // Radius (in pixels) around a click for replacement

      // Population Limit
      maxPopulation: 50,           // Maximum number of creatures allowed

      // Patch Color Evolution Settings
      neighborThreshold: 300,      // Distance within which patches influence each other
      hueAdjustmentFactor: 0.01,   // Fraction by which patch hue moves toward neighborsâ€™ average
      hueRandomDrift: 0.5,         // Maximum random change in hue per tick
      lightDrift: 0.2,             // Maximum random change in lightness per tick

      // Debug mode
      debugMode: false
    };

    /* ================================
       Utility Functions
    ================================ */
    // Returns a random HSL color string.
    function randomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;
    }

    // Returns a random number in [min, max)
    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Ray-casting point-in-polygon test.
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
                          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Helper: interpolate creature color toward grey based on "sickness" (0 = healthy, 1 = fully sick).
    // Assumes creature.color is in format "hsl(h, s%, l%)"
    function getSickColor(color, sickFactor) {
      const m = color.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m) return color;
      let h = m[1],
          s = parseInt(m[2], 10),
          l = parseInt(m[3], 10);
      let newS = Math.round(s * (1 - sickFactor));
      return `hsl(${h}, ${newS}%, ${l}%)`;
    }

    /* ================================
       Canvas Setup & Global Variables
    ================================ */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const bounds = { x: 0, y: 0, w: canvas.width, h: canvas.height };

    let patches = [];
    let creatures = [];

    /* ================================
       Terrain (Patch) Generation using a Grid
    ================================ */
    function createPatches() {
      const gridCols = Math.ceil(Math.sqrt(SIMULATION.numPatches));
      const gridRows = Math.ceil(SIMULATION.numPatches / gridCols);
      const patchWidth = canvas.width / gridCols;
      const patchHeight = canvas.height / gridRows;
      patches = [];
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const perturbX = patchWidth * 0.1;
          const perturbY = patchHeight * 0.1;
          let vertices = [
            { x: c * patchWidth + randRange(0, perturbX), y: r * patchHeight + randRange(0, perturbY) },
            { x: (c + 1) * patchWidth + randRange(-perturbX, 0), y: r * patchHeight + randRange(0, perturbY) },
            { x: (c + 1) * patchWidth + randRange(-perturbX, 0), y: (r + 1) * patchHeight + randRange(-perturbY, 0) },
            { x: c * patchWidth + randRange(0, perturbX), y: (r + 1) * patchHeight + randRange(-perturbY, 0) }
          ];
          let hue = randRange(0, 360);
          let sat = 90;
          let light = randRange(70, 85);
          patches.push({
            vertices: vertices,
            hue: hue,
            sat: sat,
            light: light,
            baseColor: `hsl(${Math.round(hue)}, ${sat}%, ${Math.round(light)}%)`
          });
        }
      }
    }

    /* ================================
       Patch Color Evolution
    ================================ */
    function updatePatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        // Compute the center of the patch.
        let center = { x: 0, y: 0 };
        for (let p of patch.vertices) {
          center.x += p.x;
          center.y += p.y;
        }
        center.x /= patch.vertices.length;
        center.y /= patch.vertices.length;
        patch.center = center;

        // Average neighbor hues.
        let sumHue = 0, count = 0;
        for (let other of patches) {
          if (other === patch) continue;
          if (!other.center) continue;
          let dx = other.center.x - center.x;
          let dy = other.center.y - center.y;
          if (Math.hypot(dx, dy) < SIMULATION.neighborThreshold) {
            sumHue += other.hue;
            count++;
          }
        }
        if (count > 0) {
          let avgHue = sumHue / count;
          patch.hue += (avgHue - patch.hue) * SIMULATION.hueAdjustmentFactor;
        }
        // Random drift.
        patch.hue += randRange(-SIMULATION.hueRandomDrift, SIMULATION.hueRandomDrift);
        patch.light += randRange(-SIMULATION.lightDrift, SIMULATION.lightDrift);
        patch.hue = (patch.hue + 360) % 360;
        patch.light = Math.min(90, Math.max(60, patch.light));
        patch.baseColor = `hsl(${Math.round(patch.hue)}, ${patch.sat}%, ${Math.round(patch.light)}%)`;
      }
    }

    // Each creature gets an extra energy boost based on the patch it is on.
    function patchEnergyBoost(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          return (patch.light - 60) * 0.01;
        }
      }
      return 0;
    }

    /* ================================
       Creature Generation & Mutation
    ================================ */
    function generateTwistedShape(numVertices, radius) {
      let points = [];
      for (let i = 0; i < numVertices; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = radius * randRange(0.5, 1.5);
        points.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
      }
      return points;
    }

    function spawnCreature() {
      let numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
      let creature = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        numVertices: numVertices,
        baseShape: generateTwistedShape(numVertices, SIMULATION.creatureRadius),
        color: randomColor(),
        energy: SIMULATION.baseEnergy,
        maxEnergy: SIMULATION.maxEnergyThreshold,
        radius: SIMULATION.creatureRadius
      };
      if (Math.random() < SIMULATION.spawnMutationChance) {
        creature.numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
        creature.baseShape = generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius);
      }
      return creature;
    }

    for (let i = 0; i < SIMULATION.initialCreatures; i++) {
      creatures.push(spawnCreature());
    }

    /* ================================
       Creature Behavior: Type & Interaction
    ================================ */
    function isHerbivore(creature) {
      return creature.numVertices % 2 === 1;
    }

    function herbivoreFeeding(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          if (patch.vertices.length % creature.numVertices === 0) {
            creature.energy += SIMULATION.herbivoreEnergyGain;
          }
          break;
        }
      }
    }

    function creaturesCollide(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const dist = Math.hypot(dx, dy);
      return dist < (c1.radius + c2.radius);
    }

    function handleCreatureCollisions() {
      for (let i = 0; i < creatures.length; i++) {
        for (let j = i + 1; j < creatures.length; j++) {
          let a = creatures[i];
          let b = creatures[j];
          if (creaturesCollide(a, b)) {
            if (!isHerbivore(a) || !isHerbivore(b)) {
              if (a.energy > b.energy * 1.1) {
                a.energy += SIMULATION.predatorEnergyGain;
                b.energy -= SIMULATION.predatorEnergyLoss;
              } else if (b.energy > a.energy * 1.1) {
                b.energy += SIMULATION.predatorEnergyGain;
                a.energy -= SIMULATION.predatorEnergyLoss;
              } else {
                const angle = Math.atan2(b.y - a.y, b.x - a.x);
                a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
                a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
                b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
                b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
              }
            } else {
              const angle = Math.atan2(b.y - a.y, b.x - a.x);
              a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
              a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
              b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
              b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
            }
          }
        }
      }
    }

    /* ================================
       Update Loop
    ================================ */
    function updateCreatures() {
      for (let creature of creatures) {
        creature.x += creature.dx;
        creature.y += creature.dy;
        if (creature.x < 0 || creature.x > canvas.width) creature.dx *= -1;
        if (creature.y < 0 || creature.y > canvas.height) creature.dy *= -1;
        creature.energy -= SIMULATION.energyDecayRate;
        creature.energy += patchEnergyBoost(creature);
        if (isHerbivore(creature)) {
          herbivoreFeeding(creature);
        }
        if (creature.energy >= creature.maxEnergy) {
          creature.energy /= 2;
          let clone = {
            x: creature.x + randRange(-5, 5),
            y: creature.y + randRange(-5, 5),
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: creature.numVertices,
            baseShape: generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius),
            color: creature.color,
            energy: creature.energy,
            maxEnergy: creature.maxEnergy,
            radius: creature.radius
          };
          creatures.push(clone);
        }
      }
      handleCreatureCollisions();
      if (creatures.length > SIMULATION.maxPopulation) {
        creatures.sort((a, b) => a.energy - b.energy);
        creatures = creatures.slice(creatures.length - SIMULATION.maxPopulation);
      }
      creatures = creatures.filter(c => c.energy > 0);
    }

    /* ================================
       Drawing Functions
    ================================ */
    function drawPatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        ctx.beginPath();
        ctx.moveTo(patch.vertices[0].x, patch.vertices[0].y);
        for (let i = 1; i < patch.vertices.length; i++) {
          ctx.lineTo(patch.vertices[i].x, patch.vertices[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = patch.baseColor;
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.stroke();
      }
    }

    function drawCreatures() {
      for (let creature of creatures) {
        ctx.save();
        ctx.translate(creature.x, creature.y);
        ctx.beginPath();
        let pts = creature.baseShape;
        for (let i = 0; i < pts.length; i++) {
          let offsetX = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let offsetY = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let x = pts[i].x + offsetX;
          let y = pts[i].y + offsetY;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        let sickFactor = Math.min(1, Math.max(0, 1 - (creature.energy / SIMULATION.baseEnergy)));
        let fillColor = getSickColor(creature.color, sickFactor);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
        ctx.restore();
      }
    }

    /* ================================
       Click Replacement: Replace creatures in a radius with a new type.
    ================================ */
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      let indicesToReplace = [];
      for (let i = 0; i < creatures.length; i++) {
        let creature = creatures[i];
        let dx = creature.x - clickX;
        let dy = creature.y - clickY;
        if (Math.hypot(dx, dy) < SIMULATION.clickReplacementRadius) {
          indicesToReplace.push(i);
        }
      }
      if (indicesToReplace.length > 0) {
        let newConfig = spawnCreature();
        indicesToReplace.forEach(index => {
          let old = creatures[index];
          creatures[index] = {
            x: old.x,
            y: old.y,
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: newConfig.numVertices,
            baseShape: generateTwistedShape(newConfig.numVertices, SIMULATION.creatureRadius),
            color: newConfig.color,
            energy: SIMULATION.baseEnergy,
            maxEnergy: SIMULATION.maxEnergyThreshold,
            radius: SIMULATION.creatureRadius
          };
        });
      }
    });

    /* ================================
       Main Game Loop
    ================================ */
    function gameLoop() {
      updatePatches();
      updateCreatures();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPatches();
      drawCreatures();
      requestAnimationFrame(gameLoop);
    }

    /* ================================
       Initialization
    ================================ */
    createPatches();
    gameLoop();
  </script>
</body>
</html>
