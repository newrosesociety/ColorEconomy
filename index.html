<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ColorEconomy</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: #111;
    }
    /* Footer styles */
    #footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: black;
      color: white;
      text-align: center;
      padding: 10px;
      box-sizing: border-box;
      z-index: 10;
    }
    /* Reset button styles */
    #resetButton {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      font-size: 16px;
      background: #222;
      color: white;
      border: 2px solid white;
      cursor: pointer;
      z-index: 10;
    }
    #resetButton:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="resetButton">Reset Simulation</button>
  <div id="footer">
    <p>
      <strong>ColorEconomy</strong> – In this simulation, the tessellated patches represent a living, shifting environment whose bold, intense hues evolve through random splashes and neighbor interactions. Creatures—symbolizing the consequences of uncontrolled intervention—either feed or battle based on their shape (odd-sided herbivores seek patches that complement them, even-sided predators dominate through combat). Your actions (clicking) induce mutations and mass replacement, exposing the fragile balance between creative diversity and ecological decay.
    </p>
  </div>
  <script>
    /* ================================
       Simulation Parameters
    ================================ */
    const SIMULATION = {
      // Terrain (Patch) Settings
      numPatches: 100,              // Total number of patch seeds (for Voronoi)
      minPatchSides: 3,            // Minimum allowed sides per patch
      maxPatchSides: 9,            // Maximum allowed sides per patch
      
      // Patch Color Evolution Settings & Splash Effects:
      neighborThreshold: 300,      // Distance within which patches influence each other
      hueAdjustmentFactor: 0.01,   // Fraction by which patch hue moves toward neighbors’ average
      hueRandomDrift: 0.5,         // Maximum random change in hue per tick
      lightDrift: 0.2,             // Maximum random change in lightness per tick
      // For bolder colors, use full saturation and a lower light range:
      boldSaturation: 100,
      boldLightMin: 50,
      boldLightMax: 70,
      splashProbability: 0.03,     // Chance per patch per tick to spawn a random color splash
      splashMaxOffset: 30,         // Maximum offset (in hue degrees) for a splash
      splashLifeDecay: 0.02,       // Amount by which the splash life decays per tick

      // Creature Settings
      initialCreatures: 500,        // Starting creature count
      minVertices: 3,              // Minimum vertices for creature shape
      maxVertices: 14,              // Maximum vertices for creature shape
      baseEnergy: 80,              // Starting energy for creatures
      maxEnergyThreshold: 150,     // Energy required for cloning
      energyDecayRate: 0.1,        // Energy lost per frame
      herbivoreEnergyGain: 0.2,    // Extra energy gain when feeding (if condition met)
      predatorEnergyGain: 10,      // Energy bonus from winning a fight
      predatorEnergyLoss: 20,      // Energy penalty from losing a fight
      movementSpeed: 1,            // Base movement speed
      creatureRadius: 15,          // For collision detection (approximate size)
      bounceFactor: 1,             // Strength of bounce on collision

      // Wiggle Settings (for creature "walking")
      wiggleRadius: 3,             // Maximum random offset per vertex per frame

      // Mutation Settings (on spawn and on click)
      spawnMutationChance: 0.3,    // Chance a newly spawned creature mutates its vertex count
      mutationChance: 1.0,         // Chance to mutate on click (if targeted)
      clickReplacementRadius: 100, // Radius (in pixels) around a click for replacement

      // Population Limit
      maxPopulation: 5000,           // Maximum number of creatures allowed

      // Debug mode
      debugMode: false
    };

    /* ================================
       Utility Functions
    ================================ */
    // Returns a random HSL color string.
    function randomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;
    }

    // Returns a random number in [min, max)
    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Ray-casting point-in-polygon test.
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
                          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Helper: interpolate creature color toward grey based on "sickness" (0 = healthy, 1 = fully sick).
    // Assumes creature.color is in format "hsl(h, s%, l%)"
    function getSickColor(color, sickFactor) {
      const m = color.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m) return color;
      let h = m[1],
          s = parseInt(m[2], 10),
          l = parseInt(m[3], 10);
      let newS = Math.round(s * (1 - sickFactor));
      return `hsl(${h}, ${newS}%, ${l}%)`;
    }

    /* ================================
       Canvas Setup & Global Variables
    ================================ */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const bounds = { x: 0, y: 0, w: canvas.width, h: canvas.height };

    let patches = [];
    let creatures = [];

    /* ================================
       Patch Energy Boost Function
       (Used by updateCreatures.)
    ================================ */
    function patchEnergyBoost(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          return (patch.light - 60) * 0.01;
        }
      }
      return 0;
    }

    /* ================================
       Terrain (Patch) Generation using Voronoi
       (Generate seeds, compute cells, and enforce a min/max number of sides.)
    ================================ */
    function createPatches() {
      let seeds = [];
      const gridCols = Math.ceil(Math.sqrt(SIMULATION.numPatches));
      const gridRows = Math.ceil(SIMULATION.numPatches / gridCols);
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (seeds.length >= SIMULATION.numPatches) break;
          const x = (c + 0.5) * canvas.width / gridCols + randRange(-50, 50);
          const y = (r + 0.5) * canvas.height / gridRows + randRange(-50, 50);
          seeds.push({ x, y });
        }
      }
      patches = [];
      for (let seed of seeds) {
        let cell = computeVoronoiCell(seed, seeds, bounds);
        // Enforce a minimum and maximum number of sides.
        if (cell.length < SIMULATION.minPatchSides) continue;
        while (cell.length > SIMULATION.maxPatchSides) {
          cell.splice(Math.floor(Math.random() * cell.length), 1);
        }
        // Use bold color settings.
        let hue = randRange(0, 360);
        let sat = SIMULATION.boldSaturation;
        let light = randRange(SIMULATION.boldLightMin, SIMULATION.boldLightMax);
        patches.push({
          vertices: cell,
          hue: hue,
          sat: sat,
          light: light,
          baseColor: `hsl(${Math.round(hue)}, ${sat}%, ${Math.round(light)}%)`,
          splash: null // for random splashes
        });
      }
    }

    // Compute the Voronoi cell for a given seed among all seeds, within bounds.
    function computeVoronoiCell(seed, seeds, bounds) {
      let cell = [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h },
        { x: bounds.x, y: bounds.y + bounds.h }
      ];
      for (let other of seeds) {
        if (other === seed) continue;
        const mid = { x: (seed.x + other.x) / 2, y: (seed.y + other.y) / 2 };
        let normal = { x: seed.x - other.x, y: seed.y - other.y };
        const len = Math.hypot(normal.x, normal.y);
        if (len === 0) continue;
        normal.x /= len;
        normal.y /= len;
        cell = clipPolygon(cell, mid, normal);
        if (cell.length === 0) break;
      }
      return cell;
    }

    // Clip a polygon (subjectPolygon) against a half‑plane defined by point p and normal.
    function clipPolygon(subjectPolygon, p, normal) {
      let outputList = [];
      for (let i = 0; i < subjectPolygon.length; i++) {
        const cur = subjectPolygon[i];
        const prev = subjectPolygon[(i - 1 + subjectPolygon.length) % subjectPolygon.length];
        const curDot = (cur.x - p.x) * normal.x + (cur.y - p.y) * normal.y;
        const prevDot = (prev.x - p.x) * normal.x + (prev.y - p.y) * normal.y;
        if (curDot >= 0) {
          if (prevDot < 0) {
            const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
            if (intersect) outputList.push(intersect);
          }
          outputList.push(cur);
        } else if (prevDot >= 0) {
          const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
          if (intersect) outputList.push(intersect);
        }
      }
      return outputList;
    }

    // Compute intersection point of lines (p1→p2) and (p3→p4).
    function lineIntersection(p1, p2, p3, p4) {
      const A1 = p2.y - p1.y;
      const B1 = p1.x - p2.x;
      const C1 = A1 * p1.x + B1 * p1.y;
      const A2 = p4.y - p3.y;
      const B2 = p3.x - p4.x;
      const C2 = A2 * p3.x + B2 * p3.y;
      const det = A1 * B2 - A2 * B1;
      if (Math.abs(det) < 0.00001) return null;
      const x = (B2 * C1 - B1 * C2) / det;
      const y = (A1 * C2 - A2 * C1) / det;
      return { x, y };
    }

    /* ================================
       Patch Color Evolution & Splash Effects
    ================================ */
    function updatePatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        // Compute the center.
        let center = { x: 0, y: 0 };
        for (let p of patch.vertices) {
          center.x += p.x;
          center.y += p.y;
        }
        center.x /= patch.vertices.length;
        center.y /= patch.vertices.length;
        patch.center = center;

        // Average neighbor hues.
        let sumHue = 0, count = 0;
        for (let other of patches) {
          if (other === patch) continue;
          if (!other.center) continue;
          let dx = other.center.x - center.x;
          let dy = other.center.y - center.y;
          if (Math.hypot(dx, dy) < SIMULATION.neighborThreshold) {
            sumHue += other.hue;
            count++;
          }
        }
        if (count > 0) {
          let avgHue = sumHue / count;
          patch.hue += (avgHue - patch.hue) * SIMULATION.hueAdjustmentFactor;
        }
        // Apply random drift.
        patch.hue += randRange(-SIMULATION.hueRandomDrift, SIMULATION.hueRandomDrift);
        patch.light += randRange(-SIMULATION.lightDrift, SIMULATION.lightDrift);
        patch.hue = (patch.hue + 360) % 360;
        patch.light = Math.min(90, Math.max(60, patch.light));

        // Splash effect: spawn a temporary hue offset.
        if (!patch.splash && Math.random() < SIMULATION.splashProbability) {
          patch.splash = {
            hueOffset: randRange(-SIMULATION.splashMaxOffset, SIMULATION.splashMaxOffset),
            life: 1
          };
        }
        if (patch.splash) {
          patch.splash.life -= SIMULATION.splashLifeDecay;
          if (patch.splash.life <= 0) {
            patch.splash = null;
          }
        }
        let effectiveHue = patch.hue + (patch.splash ? patch.splash.hueOffset * patch.splash.life : 0);
        patch.baseColor = `hsl(${Math.round(effectiveHue)}, ${patch.sat}%, ${Math.round(patch.light)}%)`;
      }
    }

    /* ================================
       Creature Generation & Mutation
    ================================ */
    function generateTwistedShape(numVertices, radius) {
      let points = [];
      for (let i = 0; i < numVertices; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = radius * randRange(0.5, 1.5);
        points.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
      }
      return points;
    }

    function spawnCreature() {
      let numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
      let creature = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        numVertices: numVertices,
        baseShape: generateTwistedShape(numVertices, SIMULATION.creatureRadius),
        color: randomColor(),
        energy: SIMULATION.baseEnergy,
        maxEnergy: SIMULATION.maxEnergyThreshold,
        radius: SIMULATION.creatureRadius
      };
      if (Math.random() < SIMULATION.spawnMutationChance) {
        creature.numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
        creature.baseShape = generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius);
      }
      return creature;
    }

    for (let i = 0; i < SIMULATION.initialCreatures; i++) {
      creatures.push(spawnCreature());
    }

    /* ================================
       Creature Behavior: Type & Interaction
    ================================ */
    function isHerbivore(creature) {
      return creature.numVertices % 2 === 1;
    }

    function herbivoreFeeding(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          if (patch.vertices.length % creature.numVertices === 0) {
            creature.energy += SIMULATION.herbivoreEnergyGain;
          }
          break;
        }
      }
    }

    function creaturesCollide(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const dist = Math.hypot(dx, dy);
      return dist < (c1.radius + c2.radius);
    }

    function handleCreatureCollisions() {
      for (let i = 0; i < creatures.length; i++) {
        for (let j = i + 1; j < creatures.length; j++) {
          let a = creatures[i];
          let b = creatures[j];
          if (creaturesCollide(a, b)) {
            if (!isHerbivore(a) || !isHerbivore(b)) {
              if (a.energy > b.energy * 1.1) {
                a.energy += SIMULATION.predatorEnergyGain;
                b.energy -= SIMULATION.predatorEnergyLoss;
              } else if (b.energy > a.energy * 1.1) {
                b.energy += SIMULATION.predatorEnergyGain;
                a.energy -= SIMULATION.predatorEnergyLoss;
              } else {
                const angle = Math.atan2(b.y - a.y, b.x - a.x);
                a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
                a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
                b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
                b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
              }
            } else {
              const angle = Math.atan2(b.y - a.y, b.x - a.x);
              a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
              a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
              b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
              b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
            }
          }
        }
      }
    }

    /* ================================
       Update Loop
    ================================ */
    function updateCreatures() {
      for (let creature of creatures) {
        creature.x += creature.dx;
        creature.y += creature.dy;
        if (creature.x < 0 || creature.x > canvas.width) creature.dx *= -1;
        if (creature.y < 0 || creature.y > canvas.height) creature.dy *= -1;
        creature.energy -= SIMULATION.energyDecayRate;
        creature.energy += patchEnergyBoost(creature);
        if (isHerbivore(creature)) {
          herbivoreFeeding(creature);
        }
        if (creature.energy >= creature.maxEnergy) {
          creature.energy /= 2;
          let clone = {
            x: creature.x + randRange(-5, 5),
            y: creature.y + randRange(-5, 5),
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: creature.numVertices,
            baseShape: generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius),
            color: creature.color,
            energy: creature.energy,
            maxEnergy: creature.maxEnergy,
            radius: creature.radius
          };
          creatures.push(clone);
        }
      }
      handleCreatureCollisions();
      if (creatures.length > SIMULATION.maxPopulation) {
        creatures.sort((a, b) => a.energy - b.energy);
        creatures = creatures.slice(creatures.length - SIMULATION.maxPopulation);
      }
      creatures = creatures.filter(c => c.energy > 0);
    }

    /* ================================
       Drawing Functions
    ================================ */
    function drawPatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        ctx.beginPath();
        ctx.moveTo(patch.vertices[0].x, patch.vertices[0].y);
        for (let i = 1; i < patch.vertices.length; i++) {
          ctx.lineTo(patch.vertices[i].x, patch.vertices[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = patch.baseColor;
        ctx.fill();
      }
    }

    function drawCreatures() {
      for (let creature of creatures) {
        ctx.save();
        ctx.translate(creature.x, creature.y);
        ctx.beginPath();
        let pts = creature.baseShape;
        for (let i = 0; i < pts.length; i++) {
          let offsetX = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let offsetY = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let x = pts[i].x + offsetX;
          let y = pts[i].y + offsetY;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        let sickFactor = Math.min(1, Math.max(0, 1 - (creature.energy / SIMULATION.baseEnergy)));
        let fillColor = getSickColor(creature.color, sickFactor);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
        ctx.restore();
      }
    }

    /* ================================
       Click Replacement:
       Replace all creatures in a radius with a new type.
    ================================ */
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      let indicesToReplace = [];
      for (let i = 0; i < creatures.length; i++) {
        let creature = creatures[i];
        let dx = creature.x - clickX;
        let dy = creature.y - clickY;
        if (Math.hypot(dx, dy) < SIMULATION.clickReplacementRadius) {
          indicesToReplace.push(i);
        }
      }
      if (indicesToReplace.length > 0) {
        let newConfig = spawnCreature();
        indicesToReplace.forEach(index => {
          let old = creatures[index];
          creatures[index] = {
            x: old.x,
            y: old.y,
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: newConfig.numVertices,
            baseShape: generateTwistedShape(newConfig.numVertices, SIMULATION.creatureRadius),
            color: newConfig.color,
            energy: SIMULATION.baseEnergy,
            maxEnergy: SIMULATION.maxEnergyThreshold,
            radius: SIMULATION.creatureRadius
          };
        });
      }
    });

    /* ================================
       Main Game Loop
    ================================ */
    function gameLoop() {
      updatePatches();
      updateCreatures();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPatches();
      drawCreatures();
      requestAnimationFrame(gameLoop);
    }

    /* ================================
       Reset Simulation Functionality
    ================================ */
    document.getElementById("resetButton").addEventListener("click", function() {
      creatures = [];
      for (let i = 0; i < SIMULATION.initialCreatures; i++) {
        creatures.push(spawnCreature());
      }
    });

    /* ================================
       Initialization
    ================================ */
    createPatches();
    gameLoop();
  </script>
</body>
</html>
