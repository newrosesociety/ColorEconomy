<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ColorEconomy</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #111;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    /* ================================
       Simulation Parameters
    ================================ */
    const SIMULATION = {
      // Terrain (Patch) Settings
      numPatches: 100,              // Number of patch seeds
      patchColorVariance: 100,      // Variation in patch brightness

      // Creature Settings
      initialCreatures: 1000,        // Starting creature count
      minVertices: 3,              // Minimum vertices for creature shape
      maxVertices: 25,              // Maximum vertices for creature shape
      baseEnergy: 80,              // Starting energy for creatures
      maxEnergyThreshold: 150,     // Energy required for cloning
      energyDecayRate: 0.1,        // Energy lost per frame
      herbivoreEnergyGain: 0.2,    // Energy gain per frame (herbivores)
      predatorEnergyGain: 10,      // Energy bonus from winning a fight
      predatorEnergyLoss: 20,      // Energy penalty from losing a fight
      movementSpeed: 1,            // Base movement speed
      creatureRadius: 15,          // For collision detection (approximate)
      bounceFactor: 1,             // Strength of bounce on collision

      // Wiggle Settings (for creature "walking")
      wiggleRadius: 2,             // Maximum random offset per vertex per frame

      // Mutation Settings (on spawn and on click)
      spawnMutationChance: 0.3,    // Chance a newly spawned creature mutates its vertex count
      mutationChance: 1.0,         // Chance to mutate on click (if clicked creature is targeted)
      clickReplacementRadius: 100, // Radius (in pixels) around a click for replacement

      // Population Limit
      maxPopulation: 2000,           // Maximum number of creatures allowed

      // Debug
      debugMode: false
    };

    /* ================================
       Utility Functions
    ================================ */
    // Returns a random HSL color string.
    function randomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;
    }

    // Returns a random number in [min, max)
    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Compute intersection point of lines (p1→p2) and (p3→p4)
    function lineIntersection(p1, p2, p3, p4) {
      const A1 = p2.y - p1.y;
      const B1 = p1.x - p2.x;
      const C1 = A1 * p1.x + B1 * p1.y;
      const A2 = p4.y - p3.y;
      const B2 = p3.x - p4.x;
      const C2 = A2 * p3.x + B2 * p3.y;
      const det = A1 * B2 - A2 * B1;
      if (Math.abs(det) < 0.00001) return null;
      const x = (B2 * C1 - B1 * C2) / det;
      const y = (A1 * C2 - A2 * C1) / det;
      return { x, y };
    }

    // Clip a polygon (subjectPolygon) against a half-plane defined by point p and normal.
    function clipPolygon(subjectPolygon, p, normal) {
      let outputList = [];
      for (let i = 0; i < subjectPolygon.length; i++) {
        const cur = subjectPolygon[i];
        const prev = subjectPolygon[(i - 1 + subjectPolygon.length) % subjectPolygon.length];
        const curDot = (cur.x - p.x) * normal.x + (cur.y - p.y) * normal.y;
        const prevDot = (prev.x - p.x) * normal.x + (prev.y - p.y) * normal.y;
        if (curDot >= 0) {
          if (prevDot < 0) {
            const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
            if (intersect) outputList.push(intersect);
          }
          outputList.push(cur);
        } else if (prevDot >= 0) {
          const intersect = lineIntersection(prev, cur, p, { x: p.x + normal.y, y: p.y - normal.x });
          if (intersect) outputList.push(intersect);
        }
      }
      return outputList;
    }

    // Compute the Voronoi cell for a given seed among all seeds, within bounds.
    function computeVoronoiCell(seed, seeds, bounds) {
      let cell = [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h },
        { x: bounds.x, y: bounds.y + bounds.h }
      ];
      for (let other of seeds) {
        if (other === seed) continue;
        const mid = { x: (seed.x + other.x) / 2, y: (seed.y + other.y) / 2 };
        let normal = { x: seed.x - other.x, y: seed.y - other.y };
        const len = Math.hypot(normal.x, normal.y);
        if (len === 0) continue;
        normal.x /= len;
        normal.y /= len;
        cell = clipPolygon(cell, mid, normal);
        if (cell.length === 0) break;
      }
      return cell;
    }

    // Ray-casting point-in-polygon test.
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
                          (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Helper: interpolate creature color toward grey based on a "sickness" factor (0 = healthy, 1 = completely sick).
    // Assumes creature.color is of the format "hsl(h, 80%, 60%)"
    function getSickColor(color, sickFactor) {
      const m = color.match(/hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%\)/);
      if (!m) return color;
      let h = m[1],
          s = parseInt(m[2], 10),
          l = parseInt(m[3], 10);
      // Reduce saturation linearly: healthy (s=80) to nearly 0 when sick.
      let newS = Math.round(80 * (1 - sickFactor));
      // Optionally, adjust lightness if desired (here we keep it at 60).
      return `hsl(${h}, ${newS}%, ${l}%)`;
    }

    /* ================================
       Canvas Setup & Global Variables
    ================================ */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const bounds = { x: 0, y: 0, w: canvas.width, h: canvas.height };

    let patches = [];
    let creatures = [];

    /* ================================
       Terrain (Patch) Generation
    ================================ */
    function createPatches() {
      let seeds = [];
      const gridCols = Math.ceil(Math.sqrt(SIMULATION.numPatches));
      const gridRows = Math.ceil(SIMULATION.numPatches / gridCols);
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (seeds.length >= SIMULATION.numPatches) break;
          const x = (c + 0.5) * canvas.width / gridCols + randRange(-50, 50);
          const y = (r + 0.5) * canvas.height / gridRows + randRange(-50, 50);
          seeds.push({ x, y });
        }
      }
      for (let seed of seeds) {
        let cell = computeVoronoiCell(seed, seeds, bounds);
        let colorVariance = randRange(-SIMULATION.patchColorVariance, SIMULATION.patchColorVariance);
        patches.push({
          vertices: cell,
          baseColor: `hsl(${randRange(0, 360)}, 80%, ${50 + colorVariance}%)`
        });
      }
    }

    /* ================================
       Creature Generation & Mutation
    ================================ */
    // Generate a twisted (possibly self-intersecting) shape.
    // This function returns an array of points (the "baseShape").
    function generateTwistedShape(numVertices, radius) {
      let points = [];
      for (let i = 0; i < numVertices; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = radius * randRange(0.5, 1.5);
        points.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
      }
      return points;
    }

    // Spawn a new creature.
    function spawnCreature() {
      let numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
      let creature = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
        numVertices: numVertices,
        baseShape: generateTwistedShape(numVertices, SIMULATION.creatureRadius),
        color: randomColor(),
        energy: SIMULATION.baseEnergy,
        maxEnergy: SIMULATION.maxEnergyThreshold,
        radius: SIMULATION.creatureRadius
      };
      // On spawn, chance to mutate its vertex count.
      if (Math.random() < SIMULATION.spawnMutationChance) {
        creature.numVertices = Math.floor(randRange(SIMULATION.minVertices, SIMULATION.maxVertices + 1));
        creature.baseShape = generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius);
      }
      return creature;
    }

    // Initially spawn creatures.
    for (let i = 0; i < SIMULATION.initialCreatures; i++) {
      creatures.push(spawnCreature());
    }

    /* ================================
       Creature Behavior: Type & Interaction
    ================================ */
    // A creature is herbivorous if it has an odd number of vertices.
    function isHerbivore(creature) {
      return creature.numVertices % 2 === 1;
    }

    // Herbivore feeding: if on a patch whose vertex count divides evenly by its own vertex count.
    function herbivoreFeeding(creature) {
      for (let patch of patches) {
        if (pointInPolygon({ x: creature.x, y: creature.y }, patch.vertices)) {
          if (patch.vertices.length % creature.numVertices === 0) {
            creature.energy += SIMULATION.herbivoreEnergyGain;
          }
          break;
        }
      }
    }

    // Check collision between two creatures (using circle approximation).
    function creaturesCollide(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const dist = Math.hypot(dx, dy);
      return dist < (c1.radius + c2.radius);
    }

    // Handle collisions between creatures: fighting and bouncing.
    function handleCreatureCollisions() {
      for (let i = 0; i < creatures.length; i++) {
        for (let j = i + 1; j < creatures.length; j++) {
          let a = creatures[i];
          let b = creatures[j];
          if (creaturesCollide(a, b)) {
            // If at least one is a predator (even vertex count) trigger a fight.
            if (!isHerbivore(a) || !isHerbivore(b)) {
              if (a.energy > b.energy * 1.1) {
                a.energy += SIMULATION.predatorEnergyGain;
                b.energy -= SIMULATION.predatorEnergyLoss;
              } else if (b.energy > a.energy * 1.1) {
                b.energy += SIMULATION.predatorEnergyGain;
                a.energy -= SIMULATION.predatorEnergyLoss;
              } else {
                // Similar energy: bounce.
                const angle = Math.atan2(b.y - a.y, b.x - a.x);
                a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
                a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
                b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
                b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
              }
            } else {
              // Two herbivores: bounce.
              const angle = Math.atan2(b.y - a.y, b.x - a.x);
              a.dx = -Math.cos(angle) * SIMULATION.bounceFactor;
              a.dy = -Math.sin(angle) * SIMULATION.bounceFactor;
              b.dx = Math.cos(angle) * SIMULATION.bounceFactor;
              b.dy = Math.sin(angle) * SIMULATION.bounceFactor;
            }
          }
        }
      }
    }

    /* ================================
       Update Loop
    ================================ */
    function updateCreatures() {
      for (let creature of creatures) {
        // Update position.
        creature.x += creature.dx;
        creature.y += creature.dy;
        // Bounce off canvas edges.
        if (creature.x < 0 || creature.x > canvas.width) creature.dx *= -1;
        if (creature.y < 0 || creature.y > canvas.height) creature.dy *= -1;
        // Energy decay.
        creature.energy -= SIMULATION.energyDecayRate;
        // Herbivore feeding.
        if (isHerbivore(creature)) {
          herbivoreFeeding(creature);
        }
        // Cloning: if energy exceeds threshold, split energy and clone.
        if (creature.energy >= creature.maxEnergy) {
          creature.energy /= 2;
          let clone = {
            x: creature.x + randRange(-5, 5),
            y: creature.y + randRange(-5, 5),
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: creature.numVertices,
            baseShape: generateTwistedShape(creature.numVertices, SIMULATION.creatureRadius),
            color: creature.color,
            energy: creature.energy,
            maxEnergy: creature.maxEnergy,
            radius: creature.radius
          };
          creatures.push(clone);
        }
      }
      handleCreatureCollisions();
      // Trim population if over limit (remove lowest-energy creatures first).
      if (creatures.length > SIMULATION.maxPopulation) {
        creatures.sort((a, b) => a.energy - b.energy);
        creatures = creatures.slice(creatures.length - SIMULATION.maxPopulation);
      }
      creatures = creatures.filter(c => c.energy > 0);
    }

    /* ================================
       Drawing Functions
    ================================ */
    // Draw patches as tessellated polygons.
    function drawPatches() {
      for (let patch of patches) {
        if (!patch.vertices || patch.vertices.length === 0) continue;
        ctx.beginPath();
        ctx.moveTo(patch.vertices[0].x, patch.vertices[0].y);
        for (let i = 1; i < patch.vertices.length; i++) {
          ctx.lineTo(patch.vertices[i].x, patch.vertices[i].y);
        }
        ctx.closePath();
        // Create a radial gradient based on the patch’s center.
        let center = { x: 0, y: 0 };
        for (let p of patch.vertices) {
          center.x += p.x;
          center.y += p.y;
        }
        center.x /= patch.vertices.length;
        center.y /= patch.vertices.length;
        let grad = ctx.createRadialGradient(center.x, center.y, 5, center.x, center.y, 150);
        grad.addColorStop(0, patch.baseColor);
        grad.addColorStop(1, "#000");
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.stroke();
      }
    }

    // Draw creatures with a "wiggle" effect and a sick appearance when low on energy.
    function drawCreatures() {
      for (let creature of creatures) {
        ctx.save();
        ctx.translate(creature.x, creature.y);
        ctx.beginPath();
        // Use the creature's baseShape and apply a random wiggle offset to each vertex.
        let pts = creature.baseShape;
        // Compute wiggle for each vertex.
        for (let i = 0; i < pts.length; i++) {
          let offsetX = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let offsetY = randRange(-SIMULATION.wiggleRadius, SIMULATION.wiggleRadius);
          let x = pts[i].x + offsetX;
          let y = pts[i].y + offsetY;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        // Determine "sickness" based on energy (if energy is low relative to baseEnergy).
        let sickFactor = Math.min(1, Math.max(0, 1 - (creature.energy / SIMULATION.baseEnergy)));
        let fillColor = getSickColor(creature.color, sickFactor);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
        ctx.restore();
      }
    }

    /* ================================
       Click Replacement: Replace all creatures in a radius with a new type.
    ================================ */
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      // Collect indices of creatures within the replacement radius.
      let indicesToReplace = [];
      for (let i = 0; i < creatures.length; i++) {
        let creature = creatures[i];
        let dx = creature.x - clickX;
        let dy = creature.y - clickY;
        if (Math.hypot(dx, dy) < SIMULATION.clickReplacementRadius) {
          indicesToReplace.push(i);
        }
      }
      // If any creatures are found, generate one new creature configuration.
      if (indicesToReplace.length > 0) {
        let newConfig = spawnCreature();
        // Replace each creature (keeping its position) with a new creature of the new configuration.
        indicesToReplace.forEach(index => {
          let old = creatures[index];
          creatures[index] = {
            x: old.x,
            y: old.y,
            dx: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            dy: randRange(-SIMULATION.movementSpeed, SIMULATION.movementSpeed),
            numVertices: newConfig.numVertices,
            baseShape: generateTwistedShape(newConfig.numVertices, SIMULATION.creatureRadius),
            color: newConfig.color,
            energy: SIMULATION.baseEnergy,  // Reset energy
            maxEnergy: SIMULATION.maxEnergyThreshold,
            radius: SIMULATION.creatureRadius
          };
        });
      }
    });

    /* ================================
       Main Game Loop
    ================================ */
    function gameLoop() {
      updateCreatures();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPatches();
      drawCreatures();
      requestAnimationFrame(gameLoop);
    }

    /* ================================
       Initialization
    ================================ */
    createPatches();
    gameLoop();
  </script>
</body>
</html>
